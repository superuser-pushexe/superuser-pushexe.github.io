<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Comprehensive Explanation of flow.c</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
      background-color: #f9f9f9;
      color: #333;
    }
    h1, h2, h3 {
      color: #444;
    }
    pre {
      background-color: #eee;
      padding: 10px;
      border: 1px solid #ccc;
      overflow-x: auto;
    }
    code {
      font-family: Consolas, monospace;
      background-color: #f4f4f4;
      padding: 2px 4px;
      border-radius: 4px;
    }
    details {
      margin: 10px 0;
      padding: 10px;
      background-color: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    summary {
      font-size: 1.1em;
      font-weight: bold;
      cursor: pointer;
    }
    .tooltip {
      position: relative;
      border-bottom: 1px dotted #000;
      cursor: help;
    }
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 230px;
      background-color: #555;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -115px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
  </style>
</head>
<body>
  <h1>Comprehensive Line-by-Line Explanation of flow.c</h1>
  <p>
    This website explains every single line of the <code>flow.c</code> source file, a lightweight X11 desktop environment built using the XCB library. The page is organized into collapsible sections. Click each header to expand the section and explore detailed commentary—including tooltips that give extra context when you hover over key terms.
  </p>

  <!-- Section: File Header & Includes -->
  <details open>
    <summary>File Header &amp; Includes (Lines 1-11)</summary>
    <div>
      <pre>
// flow.c - Lightweight X11 desktop environment using XCB
      </pre>
      <p>
        <strong>Line 1:</strong> The comment <code>// flow.c - Lightweight X11 desktop environment using XCB</code> describes the file’s name and its purpose.
      </p>
      <pre>
#include &lt;xcb/xcb.h&gt;
#include &lt;xcb/xproto.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;dirent.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;gio/gio.h&gt;
#include &lt;sys/stat.h&gt;
      </pre>
      <ul>
        <li>
          <strong>Line 2:</strong> <code>#include &lt;xcb/xcb.h&gt;</code>  
          <span class="tooltip">[XCB Library]
            <span class="tooltiptext">This header is the main entry point for using the XCB library, which communicates with the X Window System.</span>
          </span>  
          – it provides fundamental X11 interface functions.
        </li>
        <li>
          <strong>Line 3:</strong> <code>#include &lt;xcb/xproto.h&gt;</code> – Includes protocol definitions and constants needed by XCB.
        </li>
        <li>
          <strong>Line 4:</strong> <code>#include &lt;stdio.h&gt;</code> – Provides standard input/output functions (e.g., <code>fprintf</code>, <code>printf</code>).
        </li>
        <li>
          <strong>Line 5:</strong> <code>#include &lt;stdlib.h&gt;</code> – Offers general utilities like <code>exit</code> and memory management functions.
        </li>
        <li>
          <strong>Line 6:</strong> <code>#include &lt;string.h&gt;</code> – Supplies string handling functions (<code>strlen</code>, <code>strstr</code>, etc.).
        </li>
        <li>
          <strong>Line 7:</strong> <code>#include &lt;dirent.h&gt;</code> – Enables directory reading functions such as <code>opendir</code> and <code>readdir</code>.
        </li>
        <li>
          <strong>Line 8:</strong> <code>#include &lt;unistd.h&gt;</code> – Contains standard symbolic constants and system call functions (like <code>fork</code> and <code>execl</code>).
        </li>
        <li>
          <strong>Line 9:</strong> <code>#include &lt;time.h&gt;</code> – Provides functions for manipulating date and time (<code>time</code>, <code>localtime</code>, <code>strftime</code>).
        </li>
        <li>
          <strong>Line 10:</strong> <code>#include &lt;gio/gio.h&gt;</code> – Part of the GNOME GIO library; used here for GSettings and application launching.
        </li>
        <li>
          <strong>Line 11:</strong> <code>#include &lt;sys/stat.h&gt;</code> – Provides file system status functions and types.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Preprocessor Defines -->
  <details>
    <summary>Preprocessor Defines (Lines 13-23)</summary>
    <div>
      <pre>
#define WIDTH_RATIO 0.8
#define HEIGHT 40
#define CLOCK_WIDTH 120
#define BUTTON_WIDTH 80
#define BUTTON_HEIGHT 30
#define APP_MENU_HEIGHT 400
#define APP_MENU_WIDTH 300
#define SETTINGS_WIDTH 300
#define SETTINGS_HEIGHT 200
#define VOL_WIDTH 200
#define VOL_HEIGHT 60
      </pre>
      <ul>
        <li>
          <strong>Line 13:</strong> <code>#define WIDTH_RATIO 0.8</code>  
          – Sets the width ratio for the taskbar relative to the screen width.
        </li>
        <li>
          <strong>Line 14:</strong> <code>#define HEIGHT 40</code>  
          – Defines the taskbar’s height in pixels.
        </li>
        <li>
          <strong>Line 15:</strong> <code>#define CLOCK_WIDTH 120</code>  
          – Width of the clock window.
        </li>
        <li>
          <strong>Line 16:</strong> <code>#define BUTTON_WIDTH 80</code>  
          – Standard width for the taskbar buttons.
        </li>
        <li>
          <strong>Line 17:</strong> <code>#define BUTTON_HEIGHT 30</code>  
          – Height for the buttons.
        </li>
        <li>
          <strong>Line 18:</strong> <code>#define APP_MENU_HEIGHT 400</code>  
          – Height of the applications menu window.
        </li>
        <li>
          <strong>Line 19:</strong> <code>#define APP_MENU_WIDTH 300</code>  
          – Width of the applications menu window.
        </li>
        <li>
          <strong>Line 20:</strong> <code>#define SETTINGS_WIDTH 300</code>  
          – Width of the settings window.
        </li>
        <li>
          <strong>Line 21:</strong> <code>#define SETTINGS_HEIGHT 200</code>  
          – Height of the settings window.
        </li>
        <li>
          <strong>Line 22:</strong> <code>#define VOL_WIDTH 200</code>  
          – Width for the volume window.
        </li>
        <li>
          <strong>Line 23:</strong> <code>#define VOL_HEIGHT 60</code>  
          – Height for the volume window.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Global Variables -->
  <details>
    <summary>Global Variables (Immediately after Defines)</summary>
    <div>
      <pre>
xcb_connection_t *conn;
xcb_screen_t *screen;
xcb_window_t root, taskbar, app_button, notif_button, logout_button, clock_win;
xcb_window_t app_menu = 0, settings_win = 0, volume_win = 0;
xcb_gcontext_t gc;
      </pre>
      <ul>
        <li>
          <strong>xcb_connection_t *conn;</strong>  
          – Pointer to the connection to the X server.
        </li>
        <li>
          <strong>xcb_screen_t *screen;</strong>  
          – Pointer to the screen structure that holds information about the display.
        </li>
        <li>
          <strong>xcb_window_t root, taskbar, app_button, notif_button, logout_button, clock_win;</strong>  
          – Variables representing window IDs: <code>root</code> is the main root window; <code>taskbar</code> and various buttons and the clock window are child windows.
        </li>
        <li>
          <strong>xcb_window_t app_menu = 0, settings_win = 0, volume_win = 0;</strong>  
          – Window IDs for the application menu, settings window, and volume window. They are initialized to 0 (meaning “not created”).
        </li>
        <li>
          <strong>xcb_gcontext_t gc;</strong>  
          – The graphics context used for drawing operations.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Function setup_cursor -->
  <details>
    <summary>Function: setup_cursor() (Lines ~25-32)</summary>
    <div>
      <pre>
void setup_cursor() {
    xcb_cursor_t cursor = xcb_generate_id(conn);
    xcb_create_glyph_cursor(conn, cursor, screen->default_colormap,
                           screen->default_colormap, XC_left_ptr, 0, 0, 0, 0xFFFF, 0xFFFF, 0xFFFF);
    xcb_change_window_attributes(conn, root, XCB_CW_CURSOR, &cursor);
    xcb_free_cursor(conn, cursor);
    xcb_flush(conn);
}
      </pre>
      <ul>
        <li>
          **Line 1:** <code>void setup_cursor() {</code>  
          – Begins the function definition for <em>setup_cursor</em>, which will set the mouse pointer (cursor) for the root window.
        </li>
        <li>
          **Line 2:** <code>xcb_cursor_t cursor = xcb_generate_id(conn);</code>  
          – Generates a new unique identifier for a cursor using the current X connection (<code>conn</code>).
        </li>
        <li>
          **Line 3-4:** <code>xcb_create_glyph_cursor(conn, cursor, screen->default_colormap,<br>
                           screen->default_colormap, XC_left_ptr, 0, 0, 0, 0xFFFF, 0xFFFF, 0xFFFF);</code>  
          – Creates a glyph cursor. It uses the default colormap twice (for source and mask) and sets the cursor shape to <code>XC_left_ptr</code> (a standard pointer icon). The numeric parameters (0, 0, 0, 0xFFFF, 0xFFFF, 0xFFFF) define the foreground and background colors.
          <span class="tooltip">[Glyph Cursor]
            <span class="tooltiptext">Glyph cursors are created from font glyphs. Here, they ensure the pointer looks standard.</span>
          </span>
        </li>
        <li>
          **Line 5:** <code>xcb_change_window_attributes(conn, root, XCB_CW_CURSOR, &cursor);</code>  
          – Sets the cursor attribute of the root window to the newly created cursor.
        </li>
        <li>
          **Line 6:** <code>xcb_free_cursor(conn, cursor);</code>  
          – Frees the cursor resource on the client side since the cursor is now owned by the server.
        </li>
        <li>
          **Line 7:** <code>xcb_flush(conn);</code>  
          – Forces all pending commands to be sent to the X server immediately.
        </li>
        <li>
          **Line 8:** <code>}</code>  
          – Ends the function.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Function set_wallpaper -->
  <details>
    <summary>Function: set_wallpaper() (Lines ~34-39)</summary>
    <div>
      <pre>
void set_wallpaper() {
    GSettings *settings = g_settings_new("org.gnome.desktop.background");
    g_settings_set_string(settings, "picture-uri", "file:///usr/share/backgrounds/default.jpg");
    g_object_unref(settings);
}
      </pre>
      <ul>
        <li>
          **Line 1:** <code>void set_wallpaper() {</code>  
          – Begins a function that sets the desktop wallpaper.
        </li>
        <li>
          **Line 2:** <code>GSettings *settings = g_settings_new("org.gnome.desktop.background");</code>  
          – Creates a new <code>GSettings</code> object for the GNOME desktop background schema.
        </li>
        <li>
          **Line 3:** <code>g_settings_set_string(settings, "picture-uri", "file:///usr/share/backgrounds/default.jpg");</code>  
          – Sets the <code>picture-uri</code> key to point to the wallpaper image file.
        </li>
        <li>
          **Line 4:** <code>g_object_unref(settings);</code>  
          – Decreases the reference count of the <code>settings</code> object, freeing it if no longer needed.
        </li>
        <li>
          **Line 5:** <code>}</code>  
          – Ends the function.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Function draw_text -->
  <details>
    <summary>Function: draw_text(xcb_window_t, int, int, const char*, uint32_t) (Lines ~41-47)</summary>
    <div>
      <pre>
void draw_text(xcb_window_t win, int x, int y, const char *txt, uint32_t color) {
    xcb_change_gc(conn, gc, XCB_GC_FOREGROUND, &color);
    xcb_image_text_8(conn, strlen(txt), win, gc, x, y, txt);
    xcb_flush(conn);
}
      </pre>
      <ul>
        <li>
          **Line 1:** The function declaration defines <code>draw_text</code> to draw a text string on a given window. Parameters include the window (<code>win</code>), x and y coordinates, the text (<code>txt</code>), and the color.
        </li>
        <li>
          **Line 2:** <code>xcb_change_gc(conn, gc, XCB_GC_FOREGROUND, &color);</code> – Updates the graphics context (<code>gc</code>) to set the foreground color for drawing.
        </li>
        <li>
          **Line 3:** <code>xcb_image_text_8(conn, strlen(txt), win, gc, x, y, txt);</code> – Draws an 8-bit text string into the window at the specified coordinates.
        </li>
        <li>
          **Line 4:** <code>xcb_flush(conn);</code> – Flushes the command buffer so that drawing appears immediately.
        </li>
        <li>
          **Line 5:** <code>}</code> – Ends the function.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Function launch_app -->
  <details>
    <summary>Function: launch_app(const char *) (Lines ~49-56)</summary>
    <div>
      <pre>
void launch_app(const char *desktop_file) {
    GDesktopAppInfo *app = g_desktop_app_info_new_from_filename(desktop_file);
    if (app) {
        g_app_info_launch(G_APP_INFO(app), NULL, NULL, NULL);
        g_object_unref(app);
    }
}
      </pre>
      <ul>
        <li>
          **Line 1:** Begins the <code>launch_app</code> function that accepts a string pointing to a <code>.desktop</code> file.
        </li>
        <li>
          **Line 2:** <code>GDesktopAppInfo *app = g_desktop_app_info_new_from_filename(desktop_file);</code>  
          – Loads application information from the desktop file.
        </li>
        <li>
          **Line 3:** <code>if (app) {</code>  
          – Checks if the application info was successfully loaded.
        </li>
        <li>
          **Line 4:** <code>g_app_info_launch(G_APP_INFO(app), NULL, NULL, NULL);</code>  
          – Launches the application by converting <code>app</code> into a generic <code>GAppInfo</code> and then calling <code>g_app_info_launch</code>.
        </li>
        <li>
          **Line 5:** <code>g_object_unref(app);</code>  
          – Releases the reference to the <code>app</code> object.
        </li>
        <li>
          **Line 6:** <code>}</code> – Ends the <code>if</code> block.
        </li>
        <li>
          **Line 7:** <code>}</code> – Ends the function.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Function show_app_menu -->
  <details>
    <summary>Function: show_app_menu() (Lines ~58-86)</summary>
    <div>
      <pre>
void show_app_menu() {
    if (app_menu) {
        xcb_map_window(conn, app_menu);
        xcb_flush(conn);
        return;
    }

    uint32_t values[] = {0x222222, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS};
    app_menu = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, app_menu, root, 100, 100, APP_MENU_WIDTH, APP_MENU_HEIGHT,
                      2, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual,
                      XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK, values);
    xcb_map_window(conn, app_menu);

    const char *xdg_data_dirs = getenv("XDG_DATA_DIRS");
    if (!xdg_data_dirs) xdg_data_dirs = "/usr/share:/usr/local/share";
    char *dirs = strdup(xdg_data_dirs);
    char *dir = strtok(dirs, ":");
    int y = 20;

    while (dir && y < APP_MENU_HEIGHT) {
        char path[512];
        snprintf(path, sizeof(path), "%s/applications", dir);
        DIR *d = opendir(path);
        if (d) {
            struct dirent *entry;
            while ((entry = readdir(d)) && y < APP_MENU_HEIGHT) {
                if (strstr(entry->d_name, ".desktop")) {
                    char full_path[512];
                    snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
                    GDesktopAppInfo *app = g_desktop_app_info_new_from_filename(full_path);
                    if (app) {
                        const char *name = g_app_info_get_name(G_APP_INFO(app));
                        draw_text(app_menu, 10, y, name, 0xFFFFFF);
                        y += 20;
                        g_object_unref(app);
                    }
                }
            }
            closedir(d);
        }
        dir = strtok(NULL, ":");
    }
    free(dirs);
    xcb_flush(conn);
}
      </pre>
      <ul>
        <li>
          **Line 1:** <code>void show_app_menu() {</code>  
          – Starts the function that displays the applications menu.
        </li>
        <li>
          **Line 2-5:**  
          <code>
          if (app_menu) {<br>
              xcb_map_window(conn, app_menu);<br>
              xcb_flush(conn);<br>
              return;<br>
          }
          </code>  
          – If <code>app_menu</code> already exists (i.e. it’s been created before), the function simply maps (shows) it and flushes the changes.
        </li>
        <li>
          **Line 7:** <code>uint32_t values[] = {0x222222, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS};</code>  
          – Sets initial window attributes: background color (0x222222) and event masks for exposure and button press events.
        </li>
        <li>
          **Line 8:** <code>app_menu = xcb_generate_id(conn);</code>  
          – Generates a unique ID for the <code>app_menu</code> window.
        </li>
        <li>
          **Line 9-11:**  
          <code>xcb_create_window(conn, XCB_COPY_FROM_PARENT, app_menu, root, 100, 100, APP_MENU_WIDTH, APP_MENU_HEIGHT,<br>
                      2, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual,<br>
                      XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK, values);</code>  
          – Creates the application menu window as a child of the root window with specified dimensions and attributes.
        </li>
        <li>
          **Line 12:** <code>xcb_map_window(conn, app_menu);</code>  
          – Maps (displays) the app menu window.
        </li>
        <li>
          **Line 14:** <code>const char *xdg_data_dirs = getenv("XDG_DATA_DIRS");</code>  
          – Retrieves the environment variable <code>XDG_DATA_DIRS</code>, which lists directories containing application data.
        </li>
        <li>
          **Line 15:** <code>if (!xdg_data_dirs) xdg_data_dirs = "/usr/share:/usr/local/share";</code>  
          – If the environment variable isn’t set, defaults to standard directories.
        </li>
        <li>
          **Line 16:** <code>char *dirs = strdup(xdg_data_dirs);</code>  
          – Duplicates the string so it can be tokenized safely.
        </li>
        <li>
          **Line 17:** <code>char *dir = strtok(dirs, ":");</code>  
          – Uses <code>strtok</code> to get the first directory in the colon-separated list.
        </li>
        <li>
          **Line 18:** <code>int y = 20;</code>  
          – Initializes a vertical coordinate (<code>y</code>) to start drawing application names.
        </li>
        <li>
          **Line 20-32:**  
          A <code>while</code> loop that:
          <ul>
            <li>
              Iterates over each directory in <code>dirs</code> (each directory from <code>XDG_DATA_DIRS</code>).
            </li>
            <li>
              Constructs a path to the “applications” subdirectory.
            </li>
            <li>
              Opens the directory and reads entries.
            </li>
            <li>
              For each entry that contains <code>".desktop"</code>, it:
              <ul>
                <li>
                  Builds the full file path.
                </li>
                <li>
                  Uses <code>g_desktop_app_info_new_from_filename</code> to load the desktop file.
                </li>
                <li>
                  If loaded, retrieves and draws the application name at the current <code>y</code> coordinate.
                </li>
                <li>
                  Increments <code>y</code> so the next app name is drawn lower.
                </li>
                <li>
                  Frees the <code>GDesktopAppInfo</code> object.
                </li>
              </ul>
            </li>
            <li>
              Closes the directory after processing.
            </li>
          </ul>
        </li>
        <li>
          **Line 33:** <code>dir = strtok(NULL, ":");</code>  
          – Gets the next directory in the list.
        </li>
        <li>
          **Line 35:** <code>free(dirs);</code>  
          – Releases the duplicated string memory.
        </li>
        <li>
          **Line 36:** <code>xcb_flush(conn);</code>  
          – Flushes all pending requests to ensure the window and drawn text are rendered immediately.
        </li>
        <li>
          **Line 37:** <code>}</code> – Ends the function.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Function show_settings -->
  <details>
    <summary>Function: show_settings() (Lines ~88-96)</summary>
    <div>
      <pre>
void show_settings() {
    if (settings_win) {
        xcb_map_window(conn, settings_win);
        xcb_flush(conn);
        return;
    }

    uint32_t values[] = {0x444444, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS};
    settings_win = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, settings_win, root, 200, 200, SETTINGS_WIDTH, SETTINGS_HEIGHT,
                      2, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual,
                      XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK, values);
    xcb_map_window(conn, settings_win);
    draw_text(settings_win, 10, 20, "Settings (Coming Soon)", 0xFFFFFF);
    xcb_flush(conn);
}
      </pre>
      <ul>
        <li>
          **Line 1:** Begins the function that creates (or, if already created, shows) the settings window.
        </li>
        <li>
          **Line 2-5:**  
          <code>
          if (settings_win) {<br>
              xcb_map_window(conn, settings_win);<br>
              xcb_flush(conn);<br>
              return;<br>
          }
          </code>  
          – If the settings window already exists, it is mapped (displayed) and the function returns.
        </li>
        <li>
          **Line 7:** <code>uint32_t values[] = {0x444444, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS};</code>  
          – Sets background color (0x444444) and sets event masks for exposure and button press.
        </li>
        <li>
          **Line 8:** <code>settings_win = xcb_generate_id(conn);</code>  
          – Generates a unique identifier for the settings window.
        </li>
        <li>
          **Line 9-11:**  
          Creates the settings window as a child of the root window at position (200,200) with dimensions defined by <code>SETTINGS_WIDTH</code> and <code>SETTINGS_HEIGHT</code>. It uses the previously defined <code>values</code> for attributes.
        </li>
        <li>
          **Line 12:** <code>xcb_map_window(conn, settings_win);</code>  
          – Maps (displays) the settings window.
        </li>
        <li>
          **Line 13:** <code>draw_text(settings_win, 10, 20, "Settings (Coming Soon)", 0xFFFFFF);</code>  
          – Draws a placeholder text indicating that the settings functionality is not yet implemented.
        </li>
        <li>
          **Line 14:** <code>xcb_flush(conn);</code> – Flushes the requests.
        </li>
        <li>
          **Line 15:** <code>}</code> – Ends the function.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Function show_volume -->
  <details>
    <summary>Function: show_volume() (Lines ~98-106)</summary>
    <div>
      <pre>
void show_volume() {
    if (volume_win) {
        xcb_map_window(conn, volume_win);
        xcb_flush(conn);
        return;
    }

    uint32_t values[] = {0x333355, XCB_EVENT_MASK_EXPOSURE};
    volume_win = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, volume_win, root, 250, 150, VOL_WIDTH, VOL_HEIGHT,
                      2, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual,
                      XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK, values);
    xcb_map_window(conn, volume_win);
    draw_text(volume_win, 10, 20, "Volume: use keys", 0xFFFFFF);
    xcb_flush(conn);
}
      </pre>
      <ul>
        <li>
          **Line 1:** Starts the <code>show_volume</code> function.
        </li>
        <li>
          **Line 2-5:**  
          Checks if the volume window already exists; if so, maps it and flushes the connection.
        </li>
        <li>
          **Line 7:** <code>uint32_t values[] = {0x333355, XCB_EVENT_MASK_EXPOSURE};</code>  
          – Sets up the attributes for the volume window: background color and exposure event mask.
        </li>
        <li>
          **Line 8:** <code>volume_win = xcb_generate_id(conn);</code>  
          – Generates a unique ID for the volume window.
        </li>
        <li>
          **Line 9-10:** Creates the volume window as a child of the root window positioned at (250,150) with width and height defined by <code>VOL_WIDTH</code> and <code>VOL_HEIGHT</code>.
        </li>
        <li>
          **Line 11:** <code>xcb_map_window(conn, volume_win);</code>  
          – Maps (displays) the volume window.
        </li>
        <li>
          **Line 12:** <code>draw_text(volume_win, 10, 20, "Volume: use keys", 0xFFFFFF);</code>  
          – Draws text in the volume window with instructions.
        </li>
        <li>
          **Line 13:** <code>xcb_flush(conn);</code> – Flushes the connection.
        </li>
        <li>
          **Line 14:** <code>}</code> – Ends the function.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Function change_volume -->
  <details>
    <summary>Function: change_volume(const char *) (Lines ~108-113)</summary>
    <div>
      <pre>
void change_volume(const char *cmd) {
    if (fork() == 0) {
        execl("/bin/sh", "sh", "-c", cmd, NULL);
        exit(1);
    }
}
      </pre>
      <ul>
        <li>
          **Line 1:** Begins the function which takes a command string (<code>cmd</code>) to change the volume.
        </li>
        <li>
          **Line 2:** <code>if (fork() == 0) {</code>  
          – Forks a new process. If this returns 0, we’re in the child process.
        </li>
        <li>
          **Line 3:** <code>execl("/bin/sh", "sh", "-c", cmd, NULL);</code>  
          – Executes the shell with <code>cmd</code> as its argument. This allows volume commands to be run.
        </li>
        <li>
          **Line 4:** <code>exit(1);</code>  
          – If <code>execl</code> fails, exits the child process with an error.
        </li>
        <li>
          **Line 5:** <code>}</code> – Closes the <code>if</code> block.
        </li>
        <li>
          **Line 6:** <code>}</code> – Ends the function.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Function grab_keys -->
  <details>
    <summary>Function: grab_keys() (Lines ~115-121)</summary>
    <div>
      <pre>
void grab_keys() {
    xcb_grab_key(conn, 1, root, XCB_MOD_MASK_4, XCB_NO_SYMBOL, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
    xcb_grab_key(conn, 1, root, XCB_MOD_MASK_ANY, 0x1008FF11, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC); // Vol Down
    xcb_grab_key(conn, 1, root, XCB_MOD_MASK_ANY, 0x1008FF13, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC); // Vol Up
    xcb_grab_key(conn, 1, root, XCB_MOD_MASK_ANY, 0x1008FF12, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC); // Mute
    xcb_flush(conn);
}
      </pre>
      <ul>
        <li>
          **Line 1:** Begins the <code>grab_keys</code> function used to capture specific key events.
        </li>
        <li>
          **Line 2:** <code>xcb_grab_key(conn, 1, root, XCB_MOD_MASK_4, XCB_NO_SYMBOL, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);</code>  
          – Grabs a key event (with <code>XCB_MOD_MASK_4</code>—typically the Super/Windows key) on the root window. This may be used to trigger the app menu.
        </li>
        <li>
          **Line 3:** Grabs the key corresponding to <code>0x1008FF11</code> (vol down) with any modifier.
        </li>
        <li>
          **Line 4:** Grabs the key corresponding to <code>0x1008FF13</code> (vol up).
        </li>
        <li>
          **Line 5:** Grabs the key corresponding to <code>0x1008FF12</code> (mute).
        </li>
        <li>
          **Line 6:** <code>xcb_flush(conn);</code> – Flushes the commands to ensure the grabs take effect.
        </li>
        <li>
          **Line 7:** <code>}</code> – Ends the function.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Function draw_clock -->
  <details>
    <summary>Function: draw_clock() (Lines ~123-131)</summary>
    <div>
      <pre>
void draw_clock() {
    time_t t = time(NULL);
    struct tm *tm = localtime(&t);
    char buf[64];
    strftime(buf, sizeof(buf), "%H:%M:%S", tm);

    uint32_t color = 0x333333;
    xcb_change_gc(conn, gc, XCB_GC_FOREGROUND, &color);
    xcb_poly_fill_rectangle(conn, clock_win, gc, 1, &(xcb_rectangle_t){0, 0, CLOCK_WIDTH, 30});
    draw_text(clock_win, 10, 20, buf, 0xFFFFFF);
    xcb_flush(conn);
}
      </pre>
      <ul>
        <li>
          **Line 1:** Begins the <code>draw_clock</code> function which is responsible for displaying the current time.
        </li>
        <li>
          **Line 2:** <code>time_t t = time(NULL);</code>  
          – Gets the current time as a <code>time_t</code> value.
        </li>
        <li>
          **Line 3:** <code>struct tm *tm = localtime(&t);</code>  
          – Converts the current time to local time structure.
        </li>
        <li>
          **Line 4:** <code>char buf[64];</code>  
          – Declares a buffer to hold the formatted time string.
        </li>
        <li>
          **Line 5:** <code>strftime(buf, sizeof(buf), "%H:%M:%S", tm);</code>  
          – Formats the time into a string (<code>buf</code>) in “hour:minute:second” format.
        </li>
        <li>
          **Line 7:** <code>uint32_t color = 0x333333;</code>  
          – Sets a color variable for the background of the clock area.
        </li>
        <li>
          **Line 8:** <code>xcb_change_gc(conn, gc, XCB_GC_FOREGROUND, &color);</code>  
          – Changes the graphics context's foreground color to <code>color</code>.
        </li>
        <li>
          **Line 9:** <code>xcb_poly_fill_rectangle(conn, clock_win, gc, 1, &(xcb_rectangle_t){0, 0, CLOCK_WIDTH, 30});</code>  
          – Fills a rectangle in the clock window to create a background using the current <code>gc</code>.
        </li>
        <li>
          **Line 10:** <code>draw_text(clock_win, 10, 20, buf, 0xFFFFFF);</code>  
          – Draws the formatted time string (<code>buf</code>) in white on top of the background.
        </li>
        <li>
          **Line 11:** <code>xcb_flush(conn);</code> – Flushes the drawing commands.
        </li>
        <li>
          **Line 12:** <code>}</code> – Ends the function.
        </li>
      </ul>
    </div>
  </details>

  <!-- Section: Function create_taskbar -->
  <details>
    <summary>Function: create_taskbar() (Lines ~133-156)</summary>
    <div>
      <pre>
void create_taskbar() {
    int width = screen->width_in_pixels * WIDTH_RATIO;
    int x = (screen->width_in_pixels - width) / 2;
    int y = screen->height_in_pixels - HEIGHT - 10;

    uint32_t mask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK | XCB_CW_OVERRIDE_REDIRECT;
    uint32_t values[] = {0x333333, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS, 1};

    taskbar = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, taskbar, root, x, y, width, HEIGHT, 0,
                      XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual, mask, values);
    xcb_map_window(conn, taskbar);

    // Create buttons and clock
    values[0] = 0x555555;
    values[1] = XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS;

    app_button = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, app_button, taskbar, 10, 5, BUTTON_WIDTH, BUTTON_HEIGHT,
                      0, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual, mask, values);
    xcb_map_window(conn, app_button);

    notif_button = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, notif_button, taskbar, 100, 5, BUTTON_WIDTH, BUTTON_HEIGHT,
                      0, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual, mask, values);
    xcb_map_window(conn, notif_button);

    logout_button = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, logout_button, taskbar, 190, 5, BUTTON_WIDTH, BUTTON_HEIGHT,
                      0, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual, mask, values);
    xcb_map_window(conn, logout_button);

    values[0] = 0x333333;
    values[1] = XCB_EVENT_MASK_EXPOSURE;
    clock_win = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, clock_win, taskbar, width - CLOCK_WIDTH - 10, 5, CLOCK_WIDTH, 30,
                      0, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual, mask, values);
    xcb_map_window(conn, clock_win);

    gc = xcb_generate_id(conn);
    xcb_create_gc(conn, gc, taskbar, 0, NULL);
    xcb_flush(conn);
}
      </pre>
      <ul>
        <li>
          **Line 1:** <code>void create_taskbar() {</code>  
          – Begins the definition of the <code>create_taskbar</code> function.
        </li>
        <li>
          **Line 2:** <code>int width = screen-&gt;width_in_pixels * WIDTH_RATIO;</code>  
          – Calculates the width of the taskbar using the screen’s width and the predefined <code>WIDTH_RATIO</code>.
        </li>
        <li>
          **Line 3:** <code>int x = (screen-&gt;width_in_pixels - width) / 2;</code>  
          – Centers the taskbar horizontally.
        </li>
        <li>
          **Line 4:** <code>int y = screen-&gt;height_in_pixels - HEIGHT - 10;</code>  
          – Positions the taskbar vertically near the bottom of the screen (with a 10-pixel margin).
        </li>
        <li>
          **Line 6:** <code>uint32_t mask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK | XCB_CW_OVERRIDE_REDIRECT;</code>  
          – Sets up the mask for window attributes—background pixel, event mask, and override redirection (the window manager ignores these windows).
        </li>
        <li>
          **Line 7:** <code>uint32_t values[] = {0x333333, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS, 1};</code>  
          – Defines the initial values: background color <code>0x333333</code>, event mask for exposure and button press, and a flag (commonly for override redirect).
        </li>
        <li>
          **Line 9:** <code>taskbar = xcb_generate_id(conn);</code> – Generates a unique ID for the taskbar.
        </li>
        <li>
          **Line 10-12:** Creates the taskbar window with the calculated <code>x</code>, <code>y</code>, <code>width</code>, and predefined <code>HEIGHT</code>.
        </li>
        <li>
          **Line 13:** <code>xcb_map_window(conn, taskbar);</code> – Maps (displays) the taskbar.
        </li>
        <li>
          **Line 15:** Comment <code>// Create buttons and clock</code> explains that the following lines create child windows.
        </li>
        <li>
          **Line 16-17:**  
          Updates <code>values</code> for the buttons (background color <code>0x555555</code> and event masks).
        </li>
        <li>
          **Line 19-21:** Creates <code>app_button</code> as a child window of the taskbar at position (10,5) with dimensions defined by <code>BUTTON_WIDTH</code> and <code>BUTTON_HEIGHT</code>.
        </li>
        <li>
          **Line 22:** Maps the app button.
        </li>
        <li>
          **Line 24-26:** Similarly, creates and maps the <code>notif_button</code> (notification button) at (100,5).
        </li>
        <li>
          **Line 28-30:** Creates and maps the <code>logout_button</code> at (190,5).
        </li>
        <li>
          **Line 32-34:**  
          Updates <code>values</code> for the clock window (background color reverts to <code>0x333333</code> and event mask for exposure only), generates an ID, creates, and maps the clock window positioned at the right side of the taskbar.
        </li>
        <li>
          **Line 36:** <code>gc = xcb_generate_id(conn);</code> – Generates an ID for the graphics context.
        </li>
        <li>
          **Line 37:** <code>xcb_create_gc(conn, gc, taskbar, 0, NULL);</code> – Creates the graphics context for drawing on the taskbar.
        </li>
        <li>
          **Line 38:** <code>xcb_flush(conn);</code> – Flushes the XCB
