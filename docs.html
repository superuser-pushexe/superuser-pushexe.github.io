<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Flow Desktop Docs</title>
  <!-- Tailwind CSS -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet" />
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet" />
  <style>
    /* Theme Variables with Gradient Backgrounds */
    :root {
      --bg-gradient-light: linear-gradient(135deg, #f9f9f9, #dde7f7);
      --text-color-light: #333;
      --bg-gradient-dark: linear-gradient(135deg, #1a202c, #323946);
      --text-color-dark: #e2e8f0;
      --primary-color: #3b82f6;
    }
    body {
      font-family: 'Inter', sans-serif;
      transition: background 0.5s ease, color 0.5s ease;
    }
    .light-mode {
      background: var(--bg-gradient-light);
      color: var(--text-color-light);
    }
    .dark-mode {
      background: var(--bg-gradient-dark);
      color: var(--text-color-dark);
    }
    /* Glassmorphism for panels */
    .glass-panel {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(12px);
      padding: 20px;
      border-radius: 20px;
      box-shadow: 0 4px 14px rgba(0, 0, 0, 0.15);
      transition: transform 0.3s ease-in-out;
    }
    .glass-panel:hover {
      transform: scale(1.02);
    }
    /* Animations */
    @keyframes fadeIn {
      0% { opacity: 0; transform: translateY(20px); }
      100% { opacity: 1; transform: translateY(0); }
    }
    .animate-fade {
      animation: fadeIn 1s ease forwards;
    }
    @keyframes slideInLeft {
      0% { opacity: 0; transform: translateX(-50px); }
      100% { opacity: 1; transform: translateX(0); }
    }
    .animate-slide-left {
      animation: slideInLeft 1s ease forwards;
    }
    /* Scroll-triggered initial hidden state */
    .animate-on-scroll {
      opacity: 0;
      transform: translateY(20px);
      transition: opacity 1s ease-out, transform 1s ease-out;
    }
    .in-view {
      opacity: 1;
      transform: translateY(0);
    }
    /* Code block styling */
    pre {
      background-color: #1a202c;
      color: #cbd5e0;
      padding: 15px;
      border-radius: 8px;
      overflow-x: auto;
    }
    code {
      font-family: Consolas, monospace;
    }
    /* Details and summary styling */
    details {
      margin: 1rem 0;
    }
    summary {
      cursor: pointer;
      font-weight: 600;
      padding: 0.5rem;
      background-color: var(--primary-color);
      color: white;
      border-radius: 0.5rem;
    }
    .tooltip {
      position: relative;
      border-bottom: 1px dotted #000;
      cursor: help;
    }
    .tooltip .tooltiptext {
      visibility: hidden;
      width: 230px;
      background-color: #555;
      color: #fff;
      text-align: left;
      border-radius: 6px;
      padding: 5px;
      position: absolute;
      z-index: 1;
      bottom: 125%;
      left: 50%;
      margin-left: -115px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .tooltip:hover .tooltiptext {
      visibility: visible;
      opacity: 1;
    }
    /* Navigation header */
    header {
      background: rgba(17, 24, 39, 0.8);
      backdrop-filter: blur(10px);
    }
  </style>
</head>
<body class="light-mode">
  <!-- Navigation Bar -->
  <header class="fixed top-0 w-full z-50 animate-fade">
    <div class="flex items-center justify-between px-6 py-4">
      <h1 class="text-4xl font-bold text-primary animate-slide-left">
        Flow Desktop Docs
      </h1>
      <nav class="space-x-4">
        <a href="#file-header" class="text-white hover:text-blue-400">File Header</a>
        <a href="#defines" class="text-white hover:text-blue-400">Defines</a>
        <a href="#globals" class="text-white hover:text-blue-400">Globals</a>
        <a href="#functions" class="text-white hover:text-blue-400">Functions</a>
      </nav>
      <button id="theme-toggle" class="p-2 bg-blue-500 text-white rounded-lg animate-pulse">Toggle Theme</button>
    </div>
  </header>
  
  <!-- Spacer to push content below fixed nav -->
  <div class="h-24"></div>
  
  <main class="max-w-5xl mx-auto px-6 pb-12 space-y-8">
    <!-- Section: File Header & Includes -->
    <section id="file-header" class="glass-panel animate-on-scroll">
      <h2 class="text-3xl font-bold mb-4">File Header &amp; Includes (Lines 1-11)</h2>
      <pre>
  // flow.c - Lightweight X11 desktop environment using XCB
      </pre>
      <p class="mt-2">
        This comment at the top describes the file’s name and its purpose.
      </p>
      <pre>
#include &lt;xcb/xcb.h&gt;
#include &lt;xcb/xproto.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;dirent.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;gio/gio.h&gt;
#include &lt;sys/stat.h&gt;
      </pre>
      <ul class="list-disc list-inside mt-2">
        <li><strong>#include &lt;xcb/xcb.h&gt;</strong>: Main XCB functions for interacting with the X server.</li>
        <li><strong>#include &lt;xcb/xproto.h&gt;</strong>: Contains protocol definitions and constants.</li>
        <li><strong>#include &lt;stdio.h&gt;</strong>: Standard I/O functions.</li>
        <li><strong>#include &lt;stdlib.h&gt;</strong>: Memory management and general utilities.</li>
        <li><strong>#include &lt;string.h&gt;</strong>: String handling.</li>
        <li><strong>#include &lt;dirent.h&gt;</strong>: Directory reading functions.</li>
        <li><strong>#include &lt;unistd.h&gt;</strong>: Unix standard functions such as fork and execl.</li>
        <li><strong>#include &lt;time.h&gt;</strong>: Date and time manipulation.</li>
        <li><strong>#include &lt;gio/gio.h&gt;</strong>: GNOME GIO library, used for GSettings and launching applications.</li>
        <li><strong>#include &lt;sys/stat.h&gt;</strong>: File system status functions.</li>
      </ul>
    </section>

    <!-- Section: Preprocessor Defines -->
    <section id="defines" class="glass-panel animate-on-scroll">
      <h2 class="text-3xl font-bold mb-4">Preprocessor Defines (Lines 13-23)</h2>
      <pre>
#define WIDTH_RATIO 0.8
#define HEIGHT 40
#define CLOCK_WIDTH 120
#define BUTTON_WIDTH 80
#define BUTTON_HEIGHT 30
#define APP_MENU_HEIGHT 400
#define APP_MENU_WIDTH 300
#define SETTINGS_WIDTH 300
#define SETTINGS_HEIGHT 200
#define VOL_WIDTH 200
#define VOL_HEIGHT 60
      </pre>
      <ul class="list-disc list-inside mt-2">
        <li><strong>WIDTH_RATIO</strong>: Sets the width of the taskbar relative to the screen width.</li>
        <li><strong>HEIGHT</strong>: Height of the taskbar in pixels.</li>
        <li><strong>CLOCK_WIDTH</strong>: Width of the clock window.</li>
        <li><strong>BUTTON_WIDTH</strong> &amp; <strong>BUTTON_HEIGHT</strong>: Dimensions for taskbar buttons.</li>
        <li><strong>APP_MENU_HEIGHT</strong> &amp; <strong>APP_MENU_WIDTH</strong>: Dimensions for the applications menu.</li>
        <li><strong>SETTINGS_WIDTH</strong> &amp; <strong>SETTINGS_HEIGHT</strong>: Dimensions for the settings window.</li>
        <li><strong>VOL_WIDTH</strong> &amp; <strong>VOL_HEIGHT</strong>: Dimensions for the volume control window.</li>
      </ul>
    </section>

    <!-- Section: Global Variables -->
    <section id="globals" class="glass-panel animate-on-scroll">
      <h2 class="text-3xl font-bold mb-4">Global Variables</h2>
      <pre>
xcb_connection_t *conn;
xcb_screen_t *screen;
xcb_window_t root, taskbar, app_button, notif_button, logout_button, clock_win;
xcb_window_t app_menu = 0, settings_win = 0, volume_win = 0;
xcb_gcontext_t gc;
      </pre>
      <ul class="list-disc list-inside mt-2">
        <li><strong>conn</strong>: X server connection.</li>
        <li><strong>screen</strong>: Information about the display screen.</li>
        <li><strong>root, taskbar, app_button, ...</strong>: Window identifiers for various UI components.</li>
        <li><strong>app_menu, settings_win, volume_win</strong>: Windows initially set to 0 (not created).</li>
        <li><strong>gc</strong>: Graphics context for drawing operations.</li>
      </ul>
    </section>

    <!-- Section: Functions -->
    <section id="functions" class="glass-panel animate-on-scroll">
      <h2 class="text-3xl font-bold mb-4">Functions</h2>
      
      <!-- setup_cursor() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: setup_cursor()</summary>
        <div class="mt-2 space-y-2">
          <pre>
void setup_cursor() {
    xcb_cursor_t cursor = xcb_generate_id(conn);
    xcb_create_glyph_cursor(conn, cursor, screen->default_colormap,
                           screen->default_colormap, XC_left_ptr, 0, 0, 0, 0xFFFF, 0xFFFF, 0xFFFF);
    xcb_change_window_attributes(conn, root, XCB_CW_CURSOR, &cursor);
    xcb_free_cursor(conn, cursor);
    xcb_flush(conn);
}
          </pre>
          <ul class="list-disc list-inside">
            <li><strong>Line 1:</strong> Declare the function to set the default cursor.</li>
            <li><strong>Line 2:</strong> Generate a unique cursor ID.</li>
            <li><strong>Line 3-4:</strong> Create the glyph cursor using the default colormap and standard pointer (<span class="tooltip">XC_left_ptr<span class="tooltiptext">Standard arrow pointer glyph.</span></span>).</li>
            <li><strong>Line 5:</strong> Assign the newly created cursor to the root window.</li>
            <li><strong>Line 6:</strong> Free the local cursor resource now that it’s managed by the server.</li>
            <li><strong>Line 7:</strong> Flush the request stream to the X server.</li>
          </ul>
        </div>
      </details>
      
      <!-- set_wallpaper() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: set_wallpaper()</summary>
        <div class="mt-2 space-y-2">
          <pre>
void set_wallpaper() {
    GSettings *settings = g_settings_new("org.gnome.desktop.background");
    g_settings_set_string(settings, "picture-uri", "file:///usr/share/backgrounds/default.jpg");
    g_object_unref(settings);
}
          </pre>
          <ul class="list-disc list-inside">
            <li><strong>Line 1:</strong> Start a function to set the desktop wallpaper.</li>
            <li><strong>Line 2:</strong> Create a new GSettings instance for the GNOME desktop background schema.</li>
            <li><strong>Line 3:</strong> Set the <code>picture-uri</code> to the path of the wallpaper.</li>
            <li><strong>Line 4:</strong> Unref the settings object to free it.</li>
          </ul>
        </div>
      </details>
      
      <!-- draw_text() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: draw_text()</summary>
        <div class="mt-2 space-y-2">
          <pre>
void draw_text(xcb_window_t win, int x, int y, const char *txt, uint32_t color) {
    xcb_change_gc(conn, gc, XCB_GC_FOREGROUND, &color);
    xcb_image_text_8(conn, strlen(txt), win, gc, x, y, txt);
    xcb_flush(conn);
}
          </pre>
          <ul class="list-disc list-inside">
            <li><strong>Line 1:</strong> Define function parameters: target window, coordinates, text, and color.</li>
            <li><strong>Line 2:</strong> Set the foreground color for drawing using the graphics context.</li>
            <li><strong>Line 3:</strong> Render the 8-bit text into the window.</li>
            <li><strong>Line 4:</strong> Flush the changes to display the text immediately.</li>
          </ul>
        </div>
      </details>
      
      <!-- launch_app() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: launch_app()</summary>
        <div class="mt-2 space-y-2">
          <pre>
void launch_app(const char *desktop_file) {
    GDesktopAppInfo *app = g_desktop_app_info_new_from_filename(desktop_file);
    if (app) {
        g_app_info_launch(G_APP_INFO(app), NULL, NULL, NULL);
        g_object_unref(app);
    }
}
          </pre>
          <ul class="list-disc list-inside">
            <li><strong>Line 1:</strong> Function to launch an application based on a .desktop file.</li>
            <li><strong>Line 2:</strong> Load application info from the given filename.</li>
            <li><strong>Line 3:</strong> Check if loading was successful.</li>
            <li><strong>Line 4:</strong> Launch the application using its app info.</li>
            <li><strong>Line 5:</strong> Free the application info object.</li>
          </ul>
        </div>
      </details>
      
      <!-- show_app_menu() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: show_app_menu()</summary>
        <div class="mt-2 space-y-2">
          <pre>
void show_app_menu() {
    if (app_menu) {
        xcb_map_window(conn, app_menu);
        xcb_flush(conn);
        return;
    }

    uint32_t values[] = {0x222222, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS};
    app_menu = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, app_menu, root, 100, 100, APP_MENU_WIDTH, APP_MENU_HEIGHT,
                      2, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual,
                      XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK, values);
    xcb_map_window(conn, app_menu);

    const char *xdg_data_dirs = getenv("XDG_DATA_DIRS");
    if (!xdg_data_dirs) xdg_data_dirs = "/usr/share:/usr/local/share";
    char *dirs = strdup(xdg_data_dirs);
    char *dir = strtok(dirs, ":");
    int y = 20;

    while (dir && y < APP_MENU_HEIGHT) {
        char path[512];
        snprintf(path, sizeof(path), "%s/applications", dir);
        DIR *d = opendir(path);
        if (d) {
            struct dirent *entry;
            while ((entry = readdir(d)) && y < APP_MENU_HEIGHT) {
                if (strstr(entry->d_name, ".desktop")) {
                    char full_path[512];
                    snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);
                    GDesktopAppInfo *app = g_desktop_app_info_new_from_filename(full_path);
                    if (app) {
                        const char *name = g_app_info_get_name(G_APP_INFO(app));
                        draw_text(app_menu, 10, y, name, 0xFFFFFF);
                        y += 20;
                        g_object_unref(app);
                    }
                }
            }
            closedir(d);
        }
        dir = strtok(NULL, ":");
    }
    free(dirs);
    xcb_flush(conn);
}
          </pre>
          <ul class="list-disc list-inside">
            <li><strong>Lines 1-5:</strong> If the app menu exists, simply remap (show) it.</li>
            <li><strong>Lines 7-11:</strong> Otherwise, set window attributes (background color and event masks) and create the app menu window.</li>
            <li><strong>Lines 13-21:</strong> Retrieve the XDG_DATA_DIRS, split into directories, and iterate to find .desktop files.</li>
            <li><strong>Lines 22-31:</strong> For each desktop file found, load its info, get the application’s name, draw it, and increment the vertical coordinate.</li>
            <li><strong>Lines 32-33:</strong> Free the duplicated environment variable string and flush changes.</li>
          </ul>
        </div>
      </details>
      
      <!-- show_settings() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: show_settings()</summary>
        <div class="mt-2 space-y-2">
          <pre>
void show_settings() {
    if (settings_win) {
        xcb_map_window(conn, settings_win);
        xcb_flush(conn);
        return;
    }

    uint32_t values[] = {0x444444, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS};
    settings_win = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, settings_win, root, 200, 200, SETTINGS_WIDTH, SETTINGS_HEIGHT,
                      2, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual,
                      XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK, values);
    xcb_map_window(conn, settings_win);
    draw_text(settings_win, 10, 20, "Settings (Coming Soon)", 0xFFFFFF);
    xcb_flush(conn);
}
          </pre>
          <ul class="list-disc list-inside">
            <li><strong>Lines 1-5:</strong> Checks if the settings window exists, maps it if it does.</li>
            <li><strong>Lines 7-11:</strong> Otherwise, creates the window in a specified location and size.</li>
            <li><strong>Lines 12-13:</strong> Draws placeholder text and flushes changes.</li>
          </ul>
        </div>
      </details>
      
      <!-- show_volume() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: show_volume()</summary>
        <div class="mt-2 space-y-2">
          <pre>
void show_volume() {
    if (volume_win) {
        xcb_map_window(conn, volume_win);
        xcb_flush(conn);
        return;
    }

    uint32_t values[] = {0x333355, XCB_EVENT_MASK_EXPOSURE};
    volume_win = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, volume_win, root, 250, 150, VOL_WIDTH, VOL_HEIGHT,
                      2, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual,
                      XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK, values);
    xcb_map_window(conn, volume_win);
    draw_text(volume_win, 10, 20, "Volume: use keys", 0xFFFFFF);
    xcb_flush(conn);
}
          </pre>
          <ul class="list-disc list-inside">
            <li>Similar to <code>show_settings()</code>, this function maps or creates the volume window and then draws instructions in it.</li>
          </ul>
        </div>
      </details>
      
      <!-- change_volume() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: change_volume()</summary>
        <div class="mt-2 space-y-2">
          <pre>
void change_volume(const char *cmd) {
    if (fork() == 0) {
        execl("/bin/sh", "sh", "-c", cmd, NULL);
        exit(1);
    }
}
          </pre>
          <ul class="list-disc list-inside">
            <li><strong>Line 1:</strong> Begin function to modify volume using a command string.</li>
            <li><strong>Line 2:</strong> Create a child process using <code>fork()</code>.</li>
            <li><strong>Line 3:</strong> In the child process, execute the command via a shell.</li>
            <li><strong>Line 4:</strong> If execution fails, exit with an error code.</li>
          </ul>
        </div>
      </details>
      
      <!-- grab_keys() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: grab_keys()</summary>
        <div class="mt-2 space-y-2">
          <pre>
void grab_keys() {
    xcb_grab_key(conn, 1, root, XCB_MOD_MASK_4, XCB_NO_SYMBOL, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
    xcb_grab_key(conn, 1, root, XCB_MOD_MASK_ANY, 0x1008FF11, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC); // Vol Down
    xcb_grab_key(conn, 1, root, XCB_MOD_MASK_ANY, 0x1008FF13, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC); // Vol Up
    xcb_grab_key(conn, 1, root, XCB_MOD_MASK_ANY, 0x1008FF12, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC); // Mute
    xcb_flush(conn);
}
          </pre>
          <ul class="list-disc list-inside">
            <li>Grabs specific key events for volume control and application menu access and flushes the connection.</li>
          </ul>
        </div>
      </details>
      
      <!-- draw_clock() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: draw_clock()</summary>
        <div class="mt-2 space-y-2">
          <pre>
void draw_clock() {
    time_t t = time(NULL);
    struct tm *tm = localtime(&t);
    char buf[64];
    strftime(buf, sizeof(buf), "%H:%M:%S", tm);

    uint32_t color = 0x333333;
    xcb_change_gc(conn, gc, XCB_GC_FOREGROUND, &color);
    xcb_poly_fill_rectangle(conn, clock_win, gc, 1, &(xcb_rectangle_t){0, 0, CLOCK_WIDTH, 30});
    draw_text(clock_win, 10, 20, buf, 0xFFFFFF);
    xcb_flush(conn);
}
          </pre>
          <ul class="list-disc list-inside">
            <li>Obtains the current time, formats it, and draws the clock background and text on the clock window.</li>
          </ul>
        </div>
      </details>
      
      <!-- create_taskbar() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: create_taskbar()</summary>
        <div class="mt-2 space-y-2">
          <pre>
void create_taskbar() {
    int width = screen->width_in_pixels * WIDTH_RATIO;
    int x = (screen->width_in_pixels - width) / 2;
    int y = screen->height_in_pixels - HEIGHT - 10;

    uint32_t mask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK | XCB_CW_OVERRIDE_REDIRECT;
    uint32_t values[] = {0x333333, XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS, 1};

    taskbar = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, taskbar, root, x, y, width, HEIGHT, 0,
                      XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual, mask, values);
    xcb_map_window(conn, taskbar);

    // Create buttons and clock
    values[0] = 0x555555;
    values[1] = XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS;

    app_button = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, app_button, taskbar, 10, 5, BUTTON_WIDTH, BUTTON_HEIGHT,
                      0, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual, mask, values);
    xcb_map_window(conn, app_button);

    notif_button = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, notif_button, taskbar, 100, 5, BUTTON_WIDTH, BUTTON_HEIGHT,
                      0, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual, mask, values);
    xcb_map_window(conn, notif_button);

    logout_button = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, logout_button, taskbar, 190, 5, BUTTON_WIDTH, BUTTON_HEIGHT,
                      0, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual, mask, values);
    xcb_map_window(conn, logout_button);

    values[0] = 0x333333;
    values[1] = XCB_EVENT_MASK_EXPOSURE;
    clock_win = xcb_generate_id(conn);
    xcb_create_window(conn, XCB_COPY_FROM_PARENT, clock_win, taskbar, width - CLOCK_WIDTH - 10, 5, CLOCK_WIDTH, 30,
                      0, XCB_WINDOW_CLASS_INPUT_OUTPUT, screen->root_visual, mask, values);
    xcb_map_window(conn, clock_win);

    gc = xcb_generate_id(conn);
    xcb_create_gc(conn, gc, taskbar, 0, NULL);
    xcb_flush(conn);
}
          </pre>
          <ul class="list-disc list-inside">
            <li>Calculates the taskbar’s position and size, creates the taskbar and its sub-windows (buttons and clock), and sets up the graphics context (gc).</li>
          </ul>
        </div>
      </details>
      
      <!-- cleanup() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: cleanup()</summary>
        <div class="mt-2 space-y-2">
          <pre>
void cleanup() {
    if (app_menu) xcb_destroy_window(conn, app_menu);
    if (settings_win) xcb_destroy_window(conn, settings_win);
    if (volume_win) xcb_destroy_window(conn, volume_win);
    xcb_destroy_window(conn, taskbar);
    xcb_destroy_window(conn, app_button);
    xcb_destroy_window(conn, notif_button);
    xcb_destroy_window(conn, logout_button);
    xcb_destroy_window(conn, clock_win);
    xcb_free_gc(conn, gc);
    xcb_disconnect(conn);
}
          </pre>
          <ul class="list-disc list-inside">
            <li>Destroys all created windows, frees the graphics context, and disconnects from the X server.</li>
          </ul>
        </div>
      </details>
      
      <!-- main() -->
      <details class="mb-4">
        <summary class="bg-blue-500 text-white rounded p-2">Function: main()</summary>
        <div class="mt-2 space-y-2">
          <pre>
int main() {
    conn = xcb_connect(NULL, NULL);
    if (xcb_connection_has_error(conn)) {
        fprintf(stderr, "Cannot connect to X server\n");
        return 1;
    }

    screen = xcb_setup_roots_iterator(xcb_get_setup(conn)).data;
    root = screen->root;

    create_taskbar();
    setup_cursor();
    set_wallpaper();
    grab_keys();

    xcb_generic_event_t *e;
    while ((e = xcb_wait_for_event(conn))) {
        switch (e->response_type & ~0x80) {
        case XCB_KEY_PRESS: {
            xcb_key_press_event_t *ke = (xcb_key_press_event_t *)e;
            if (ke->detail == XCB_NO_SYMBOL && (ke->state & XCB_MOD_MASK_4)) {
                show_app_menu();
            } else if (ke->detail == 0x1008FF13) {
                change_volume("pactl set-sink-volume @DEFAULT_SINK@ +5%");
            } else if (ke->detail == 0x1008FF11) {
                change_volume("pactl set-sink-volume @DEFAULT_SINK@ -5%");
            } else if (ke->detail == 0x1008FF12) {
                change_volume("pactl set-sink-mute @DEFAULT_SINK@ toggle");
            }
            break;
        }
        case XCB_EXPOSE: {
            xcb_expose_event_t *ee = (xcb_expose_event_t *)e;
            if (ee->window == app_button) draw_text(app_button, 10, 20, "Apps", 0xFFFFFF);
            else if (ee->window == notif_button) draw_text(notif_button, 5, 20, "Notify", 0xFFFFFF);
            else if (ee->window == logout_button) draw_text(logout_button, 5, 20, "Logout", 0xFFFFFF);
            else if (ee->window == clock_win) draw_clock();
            break;
        }
        case XCB_BUTTON_PRESS: {
            xcb_button_press_event_t *be = (xcb_button_press_event_t *)e;
            if (be->event == app_button) show_app_menu();
            else if (be->event == notif_button || be->event == volume_button) show_volume();
            else if (be->event == logout_button) {
                cleanup();
                exit(0);
            }
            break;
        }
        }
        free(e);
        draw_clock();
    }

    cleanup();
    return 0;
}
          </pre>
          <ul class="list-disc list-inside">
            <li><strong>Lines 1-5:</strong> Connect to the X server and verify the connection.</li>
            <li><strong>Lines 7-8:</strong> Retrieve the screen and root window.</li>
            <li><strong>Lines 10-13:</strong> Initialize UI elements: taskbar, cursor, wallpaper, and key grabs.</li>
            <li><strong>Lines 15-38:</strong> Main event loop processes key presses, expose events, and button presses to update UI or perform actions.</li>
            <li><strong>Line 39:</strong> Frees the event after processing.</li>
            <li><strong>Line 40:</strong> Continuously update the clock display.</li>
            <li><strong>Lines 42-44:</strong> Clean up resources and exit.</li>
          </ul>
        </div>
      </details>
    </section>
  </main>
  
  <!-- Footer -->
  <footer class="bg-gray-900 text-gray-400 py-6 text-center animate-fade">
    <p>© 2025 Flow Desktop by superuser-pushexe. GPL v3.0 License.</p>
    <div class="mt-4">
      <a href="https://github.com/superuser-pushexe/Flow-Desktop" class="text-blue-400 hover:underline">GitHub Repository</a>
      <a href="mailto:fullynerfed@mailfence.com" class="text-blue-400 hover:underline ml-4">Contact</a>
    </div>
  </footer>
  
  <!-- JavaScript for Theme Toggle and Scroll Animations -->
  <script>
    // Theme toggle functionality
    const themeToggleButton = document.getElementById("theme-toggle");
    const prefersDarkScheme = window.matchMedia("(prefers-color-scheme: dark)");
    
    function setTheme(mode) {
      document.body.classList.remove("light-mode", "dark-mode");
      document.body.classList.add(mode);
    }
    
    // Set initial theme based on system preference
    if (prefersDarkScheme.matches) {
      setTheme("dark-mode");
    } else {
      setTheme("light-mode");
    }
    
    // Toggle theme on button click
    themeToggleButton.addEventListener("click", () => {
      document.body.classList.toggle("dark-mode");
      document.body.classList.toggle("light-mode");
    });
    
    // Intersection Observer for scroll-triggered animations
    const animateOnScrollElements = document.querySelectorAll(".animate-on-scroll");
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          entry.target.classList.add("in-view");
        }
      });
    }, { threshold: 0.2 });
    
    animateOnScrollElements.forEach(el => {
      observer.observe(el);
    });
  </script>
</body>
</html>
